
---
##  Subtype Polymorphism（サブタイプ多態性）

### ● 概要

抽象クラスに投げた命令を、**実行時にどの派生クラスのインスタンスかを判断して、適切な処理を呼び出す**仕組み。
`if` 文や `switch` 文で明示的に型を判定しなくても、**仮想関数（virtual）** と **動的バインディング** により、自動的に振る舞いが切り替わる。

---

### ● メリット

* **条件分岐なしで挙動を変えられる**（`if (type == "dog") ...`のようなコードが不要）
* **共通インターフェースで扱える**ため、拡張が容易
* **抽象クラスを通して一貫した命令を送れる**（例：`Animal* animals[]` に `Dog`, `Cat` をまとめる）

---

### ● 動作イメージ

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() = 0; // 純粋仮想関数 → 抽象クラス
};

class Dog : public Animal {
public:
    void speak() { cout << "Woof!" << endl; }
};

class Cat : public Animal {
public:
    void speak() { cout << "Meow!" << endl; }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->speak(); // → "Woof!"（Dogが実行）
    a2->speak(); // → "Meow!"（Catが実行）

    delete a1;
    delete a2;
}
```

---

### ● 動的バインディングの仕組み

呼び出しは「変数の型」ではなく、「実際のオブジェクト型」に基づいて決定される。

```cpp
Animal* a = new Dog();
a->speak(); // 実際のオブジェクトがDog型 → Dog::speak()が呼ばれる
```

メモリ内部では、**vtable（仮想関数テーブル）** によりどの関数を呼ぶかを実行時に決めている。

---

### ● 図解イメージ

```
┌──────────────────────────────┐
│        抽象クラス (Animal)      │
│ ┌──────────────────────────┐ │
│ │ virtual void speak() = 0; ← 純粋仮想関数│ │
│ └──────────────────────────┘ │
└──────────────┬──────────────┘
               │
───────────────┼──────────────────────────────
               │
    ┌───────────────┐       ┌───────────────┐
    │ class Dog       │       │ class Cat       │
    │ void speak(){}  │       │ void speak(){}  │
    └───────────────┘       └───────────────┘
               │
               ▼
 (共通のポインタで扱える：Animal* a)
```

---

### ● まとめ文

> サブタイプ多態性とは、**抽象クラスで定義された共通の操作を、派生クラスが独自に実装し、実行時に動的に選択される**仕組みである。
> `virtual` による動的バインディングを利用することで、**条件分岐なしで異なる動作を統一的に扱える**。

---

希望があれば、これに「💡IF文で書いた場合と比べた例（非多態的な実装 vs 多態的実装）」も並べた図を作ることができます。
比較して見ると、**なぜ多態性が強力なのか**が直感的に理解できます。
作ってみますか？


めちゃくちゃ良い理解です。
かなり正しく捉えられています 👏
ただ、あと **“1段階だけ整理”** すると、より完璧な理解になります。

---

## ✅ あなたの理解の中で「完全に正しい部分」

> 親クラス → 子クラスの順でコンストラクタが呼ばれる
> スコープを抜けたときは、子クラス → 親クラスの順でデストラクタが呼ばれる

はい、**その通りです。**
これは C++ の**オブジェクト構築・破棄の基本ルール**です。

---

### 💡 例で確認

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A()  { cout << "A constructor\n"; }
    ~A() { cout << "A destructor\n"; }
};

class B : public A {
public:
    B()  { cout << "B constructor\n"; }
    ~B() { cout << "B destructor\n"; }
};

int main() {
    B obj;
}
```

### 実行結果：

```
A constructor
B constructor
B destructor
A destructor
```

→ あなたの言うとおり：

* 生成：**親 → 子**
* 破棄：**子 → 親**

この動作順序は、`virtual` がなくても**常に保証**されています。

---

## 🔍 では `virtual` が必要になる場面は？

ここが大事な補足ポイントです👇

### ● `virtual` は、コンストラクタ／デストラクタの呼び順を制御するためではありません。

むしろ目的はこうです：

> **「基底クラスのポインタ経由でdeleteしたときに、正しい派生クラスのデストラクタを呼ぶため」**

---

### 🔸 イメージ図

```cpp
Animal* a = new Dog();
delete a;
```

#### `virtual` なし

```
new Dog()
↓
Animal部分とDog部分が確保される
↓
delete a
 → コンパイラは a の型情報（Animal*）しか知らない
 → Animal::~Animal() だけ呼ぶ（Dog部分は無視！）
```

#### `virtual` あり

```
new Dog()
↓
Animalに vptr（仮想関数テーブルへのポインタ）が作られる
↓
delete a
 → vptr を辿って Dog::~Dog() → Animal::~Animal() の順で呼ぶ
```

つまり、

* **コンストラクタの呼び順は自動（親→子）**
* **デストラクタの呼び順も自動（子→親）**
* **ただし「どのデストラクタを呼ぶか」は `virtual` がないと分からない**

---

## 🧠 もう少し具体的に言うと…

| 状況                                 | 呼び出し元          | `virtual` の有無 | 実行されるデストラクタ            |
| ---------------------------------- | -------------- | ------------- | ---------------------- |
| `Dog obj;` （直接生成）                  | 静的型が `Dog`     | 不要            | `Dog→Animal` の順（自動）    |
| `Animal* a = new Dog(); delete a;` | 静的型が `Animal*` | 必要            | `Dog→Animal` の順（動的に解決） |

---

## 🔧 まとめ

| 項目                                  | 動作     | `virtual` の関係   |
| ----------------------------------- | ------ | --------------- |
| **コンストラクタ呼び出し順**                    | 親 → 子  | 自動（virtual不要）   |
| **デストラクタ呼び出し順**                     | 子 → 親  | 自動（virtual不要）   |
| **どのデストラクタを呼ぶか**（ポリモーフィズム経由のdelete） | 実行時に決定 | ✅ `virtual`が必要！ |

---

### 🔸 図でまとめると

```
生成:
┌───────┐
│ Animal │ ← まず親を構築
│────────│
│ Dog    │ ← 次に子を構築
└───────┘

破棄:
Dog::~Dog()
↓
Animal::~Animal()
```

`virtual` がなくても順序自体は同じですが、
**「どの破棄処理を呼ぶか」**を判別するために `virtual` が必要になるのです。

---

## 💬 一言でまとめると

> 🔹 「`virtual` は呼び出し順序を変えるためではなく、
> 　　**正しい型のデストラクタを呼び出す“道しるべ”** のために必要」

---

もしご希望であれば、
`virtual` がない場合の**メモリリークの再現コード**（Dogがnewした配列を解放できない例）を
実際に目で見える形で作って説明することもできます。
やってみますか？
