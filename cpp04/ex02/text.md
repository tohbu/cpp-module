
---

# 🧩 コンストラクタが呼ばれる順序

### ✅ ルール

> 1️⃣ 基底クラス（親クラス）
> 2️⃣ メンバ変数（宣言順）
> 3️⃣ 派生クラス（子クラス）本体

---

## 🐶 実際の流れ

```cpp
Dog dog;
```

この1行で、呼ばれる順はこうなります：

```
[1] Animal constructor     ← 親クラスの構築
[2] Brain constructor      ← メンバ（Brain*）をnewする箇所で呼ばれる
[3] Dog constructor        ← 自分自身（Dog）の構築
```

---

# 🧩 デストラクタの呼ばれる順序

デストラクタは **逆順** に呼ばれます。

### ✅ ルール

> 1️⃣ 派生クラス（子クラス）
> 2️⃣ メンバ変数
> 3️⃣ 基底クラス（親クラス）

---

## 🐱 実際の流れ


```
[1] Cat destructor called
[2] Brain destructor called
[3] Animal destructor called
```

---

```
Dog dog;

┌───────────────┐
│  Animal part  │ ← Animal::Animal() 呼ばれる
│───────────────│
│  Brain* _brain│ ← new Brain() → Brain::Brain() 呼ばれる
│───────────────│
│  Dog 本体     │ ← Dog::Dog() 呼ばれる
└───────────────┘
```

# ✅ まとめ表

| フェーズ    | 呼び出し順序      | 理由              |
| ------- | ----------- | --------------- |
| コンストラクタ | 親 → メンバ → 子 | 継承元から順に土台を積み上げる |
| デストラクタ  | 子 → メンバ → 親 | 上に積んだものから安全に崩す  |

---


> ✅ **結論**
>
> * コンストラクタは **親 → メンバ → 子** の順で呼ばれる
> * デストラクタは **子 → メンバ → 親** の順で呼ばれる
> * `Brain` のようなメンバは `new` する場所でコンストラクタが呼ばれる
> * `virtual ~Animal()` があるから、`delete Animal*` 経由でも正しい順で破棄される

---

ご希望があれば、
この順序を図解した **「コンストラクタ／デストラクタ呼び出し時系列図」**（箱と矢印付き）も作成できます。
作りましょうか？
