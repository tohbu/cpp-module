1. なぜ「参照」で受け取るのか？
目的：コピーを防ぐため

関数に値を「値渡し（T）」で渡すと、引数のコピーが作られます。
これは小さい型（int, double）なら問題ありませんが、
std::string や std::vector のように 大きなオブジェクトだとコピーコストが高いです


void printName(const std::string& name) {
    std::cout << name << std::endl;
}

これにより：

参照　& 	コピーはされない（効率的）
const  		値を変更できない（安全）

つまり、「効率」と「安全性」を両立しています。

| 種類       | 宣言例                 | 呼び出し例       | 説明                                 |
| -------- | ------------------- | ----------- | ---------------------------------- |
| **参照**   | `void func(int& x)` | `func(a);`  | `a` の **別名**（エイリアス）として扱う。中身を直接いじる。 |
| **ポインタ** | `void func(int* x)` | `func(&a);` | `a` の **アドレス**を渡す。間接的にいじる。         |




| 比較項目     | 参照（`T&`）             | ポインタ（`T*`）       |
| -------- | -------------------- | ---------------- |
| 宣言時の意味   | 変数の「別名」              | 変数の「アドレス」        |
| 呼び出し方法   | `func(a)`            | `func(&a)`       |
| アクセス方法   | `x`                  | `*x`             |
| 再代入      | 不可（常に同じ対象を参照）        | 可能（あとから別の場所を指せる） |
| NULLの扱い  | 不可（必ず有効な対象）          | 可（`NULL`を指せる） |
| メモリ操作の必要 | なし                   | あり（`&`や`*`が必要）   |
| 安全性      | 高い（必ず有効）             | 低い（ヌルポインタなどの危険）  |
| 主な用途     | 関数の引数・戻り値など（安全に直接扱う） | 可変性・動的配列・メモリ操作など |
